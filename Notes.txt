- dotnet CLI   => https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet
	donet --info	=> To get information about the available commands and the environment
	dotnet -h	=>  Shows more detailed documentation online for the specified command
	dotnet new --list	=> Lists available templates to be run using dotnet new
	dotnet sln	=> to add Project created to sln
	dotnet run  => to run application
	dotnet dev-certs https --trust  => to make sure our browser trust the certificate that is provided with dot net SDk
	dotnet ef migrations add [MigrationName] -o [FolderName] => to create migrations
- git commands	
	- git status => check if git is installed on this project or not
	- git init => intialize a repository in our project folder
	- 
- Extensions 
	- C#
	- C# Extensions
	- NuGet Gallery
	- SQLite
	- Angular Language Serve
	- Angular Snippets
	- Bracket Pair Colorizer 2

- create solution api
	- dotnet new sln => create solution file that is container of our projectt
	- dotnet new webapi -o 'APIProjectName' => create a API folder that has api project, 'o' for new folder
	- dotnet sln add API => to add API project created to sln
	- cd API => change directory to API project
	- dotnet run => to run API project
	- dotnet dev-certs https --trust => to make sure our browser trust the certificate that is provided with dot net SDk

- Entity Framework
	- what is Object Relational Mapper (ORM)
		- Object Relational Mapper => Translates our code into SQL commands that update our tables in the database
		- Entity Framework Features
			- Querying => allows to query our db using linq queries  
			- Change Traking => keep track of changes occurring in our entities which need to be submitted to db 
			- Saving => allows us to save the db and ef will execute insert, update and delete commands
			- Concurrency => it uses optimistic concurrency by default to protect overwriting changes made by another user 
			- Transactions => it provides automatic transaction management whilst querying or saving data
			- Caching => it also includes first level caching out of the box, so seperated querying will return data from the cach instead of hitting the db
			- Built-in conventions => like Id property name
			- Configurations => we can configure our entities and there's ways to configure these so that we can override the conventions
			- Migrations => ability to create db schema so that when we start our application or we run a particular command, we can automatically generate our db in our db server   
	- adding Entity Framework
		- Install NuGet Gallery Extensions
			- Install Microsoft.EntityFrameworkCore.Sqlite
			- Install Microsoft.EntityFrameworkCore.Design
		- Add Data Folder which have DataContext class and inherit from DbContext
		- configure in Startup class in ConfigureServices =>  
			services.AddDbContext<DataContext>(options =>
            {
                options.UseSqlite("Connection String");
            });
		- Add Connection String 
			- In appsettings.Development.json 
				"ConnectionStrings":{
					"DefaultConnection":"Data source=datingapp.db"
				}
			- In Startup.cs 
				services.AddDbContext<DataContext>(options =>
				{
					options.UseSqlite(_config.GetConnectionString("DefaultConnection"));
				});
		- Create Database
			- go to https://www.nuget.org/ and search for dotnet-ef
			- install dotnet-ef that matches the version of Entity Framework that installed earlier
		- Creating Migrations
			- dotnet ef migrations add InitialCreate -o Data/Migrations
			- dotnet  ef database update

- Adding custom API
	- in API folder => create class that inherit from ControllerBase
	- add these attributes [ApiController] & [Route("api/[controller]")] on the controller
	- inject DataContext in Custom Contoller Constructor

- Adding Angular App
	- Create new project
		- install node.js
		- npm install -g @angular/cli
		- ng new client
	- Adding CORS (cross origin resource sharing) support in the API
		- In API project => Startup.cs 
			- ConfigureServices => service.AddCors();	// order not important
			- Configure	=> app.UseCors(policy => policy.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:4200")); // add between app.UserRouting(); and app.UseEndpoints();
	- Enable Angular https
		- In Student Assets
			- install server certificate
			- create folder in angular app 'ssl'
			- add server.key & server.crt in ssl folder
			- In angular.json => serve =>  "options": {
												"sslKey": "./ssl/server.key",
												"sslCert": "./ssl/server.crt",
												"ssl": true
											},
		- In Startup.cs => Configure => app.UseCors(policy => policy.AllowAnyHeader().AllowAnyMethod().WithOrigins("https://localhost:4200")); 
- Notes
	- appsettings.Development.json => use where we can store things that we don't mind other people seeing like ConnectionString doesn't contain any password information
	- appsettings.json => for developing our application 
	- Migrations Folder should be with name 'Migrations'
	- it's recommended to use Asynchronous code when dealing with database
	- Saving code into source control
		- Install git	https://git-scm.com/
		- git init
		- dotnet new gitignore	=> ignore folders like bin and obj that is regenerated automatically when run project
		- exclude appsetting.json => in .gitignore => write => appsetting.json
		- create repository
		- in project terminal
			- git remote add origin https://github.com//
			- git push -u origin master
	- It's okay to use JQuery in Angular App
		- you can add third party JavaScript Angular without any Issues 
			JQuery manipulates to the domain object model (DOM), it can add things and remove things from the DOM 
			Angular does the same but it adds its own change detection to the DOM as well 
			so it recognizes when something has been updated inside 
			if JQuery is the thing thats manipulating the DOM, then angular change detection won't work
			So if you're using something in JQuery, you're mixing it with angular code, then you may run into problems doing this
			So don't use JQuery, use something more angular